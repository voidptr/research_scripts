# Build phylogeny from lineage files generated by analyze mode

# Written in Python 2.6
# RCK
# 10-19-11

from optparse import OptionParser
import os
import gzip
import time
from ete2a1 import Tree, NodeStyle, TreeStyle, TextFace, ImgFace

# Set up options
usage = """usage: %prog [options] output_filename path_to_draw_map_task.py lineage.dat [lineage_2.dat ... ]

"""
parser = OptionParser(usage)
parser.add_option("-p", "--phylogeny_only", action = "store_true", dest = "phylogeny_only",
                  default = False, help = "only build the phylogeny, not the images.")
parser.add_option("-n", "--no_render", action = "store_true", dest = "no_render",
                  default = False, help = "only do the analysis of win/loss. do not render phylogeny.")


## fetch the args
(options, args) = parser.parse_args()

#if options.no_render:
#    options.phylogeny_only = True ## don't bother to do anything else imagey



## parameter error
if len(args) < 1:
    parser.error("incorrect number of arguments")

outfile_name = args[0]
path_to_draw_map_task = args[1]
lineage_files = args[2:]

def print_recursive( id, tree ):
    print id
    print tree[id]
    for child in tree[id]['children'].keys():
        print_recursive( child, tree )

tree = {}

tree_phylogeny = Tree()

ts = TreeStyle()
ts.show_leaf_name = False
ts.branch_vertical_margin = 10
#ts.scale = .1


def getNodeStyle( dictionary ):
    aStyle = NodeStyle()
    for key in dictionary.keys():
        aStyle[key] = dictionary[key]

    return aStyle

## node styles
regular_node_style_fluct_bb = getNodeStyle( { 'size': 0, 'shape': 'circle', 'fgcolor': 'purple' } )
regular_node_style_fluct = getNodeStyle( { 'size': 0, 'shape': 'circle', 'fgcolor': 'darkblue' } ) 
regular_node_style_bb = getNodeStyle( { 'size': 0, 'shape': 'circle', 'fgcolor': 'red' } )
regular_node_style_none = getNodeStyle( { 'size': 0, 'shape': 'circle', 'fgcolor': 'yellow' } )

dominant_node_style_fluct_bb = getNodeStyle( { 'size': 10, 'shape': 'square', 'fgcolor': 'purple' } )
dominant_node_style_fluct  = getNodeStyle( { 'size': 10, 'shape': 'square', 'fgcolor': 'darkblue' } )
dominant_node_style_bb = getNodeStyle( { 'size': 10, 'shape': 'square', 'fgcolor': 'red' } )
dominant_node_style_none = getNodeStyle( { 'size': 10, 'shape': 'square', 'fgcolor': 'yellow' } )

## root styles
separated_style = getNodeStyle( { 'size': 15, 'fgcolor': 'pink' } )
intertwined_style = getNodeStyle( { 'size': 15,'fgcolor': 'green' } )

dominant_node_ids = []

roots = [] ## root 1 and 2

for lineage_file in lineage_files:

    update = lineage_file.split('-')[-1].split('.')[0] ## pull it out of the filename

    lineage = []
    parents = []
    updates_born = []
    time_distances_from_parent = []
    genomes = []
    bbs = []
    equals = []

    ## id will be on the last line
    dominant_id = ''

    if lineage_file[-3:] == ".gz":
        fp = gzip.open(lineage_file)
    else:
        fp = open(lineage_file)

    for line in fp:
        line = line.strip()
        if len(line) == 0 or line[0] == '#': ## skip it
            continue

        line = line.split(' ')

        if (len(line) < 12):
            continue

        lineage.append( line[1] )
        parents.append( line[2] )
        genomes.append( line[11] )
        bbs.append( line[9] )
        equals.append( line[10] )
        updates_born.append( line[0] )
        
        if ( len(time_distances_from_parent) == 0 ):
            time_distances_from_parent.append(0) ## I'm root, my damn age is 0
        else:
            time_distances_from_parent.append( int(updates_born[-1]) - int(updates_born[-2]) ) ## subtract my parent's born-on date from mine 

        dominant_id = line[1]
    fp.close()

    for i in range(0, len(lineage)):
        parent_id = parents[i]
        genome_id = lineage[i]
        update_born = updates_born[i]
        time_distance_from_parent = time_distances_from_parent[i]
        genome = genomes[i]
        fluct_task = equals[i]
        bb_task = bbs[i]

        ## first, is the parent there?
        if not parent_id in tree: ## huh. This should only ever happen if we're a root. So, add it in so we can keep track of the roots.
            tree[parent_id] = { 'parent': -1, 'children': {}, 'dominant': False, 'dominant_update': 0 }
            tree[parent_id]['node'] = tree_phylogeny ## put the root in

        tree[parent_id]['children'][ genome_id ] = True ## add the child key to the dictionary of the parent

        if not genome_id in tree: ## never seen it before, put it in the tree
            tree[genome_id] = { 'parent': parent_id, 'children': {}, 'dominant': False, 'dominant_update': 0 }

            parent = tree[parent_id]['node']
            child = parent.add_child( name=genome_id, dist=time_distance_from_parent )
            
            if ( fluct_task == '1' and bb_task == '1'):
                child.set_style(regular_node_style_fluct_bb)
            elif (fluct_task == '1'):
                child.set_style(regular_node_style_fluct)
            elif (bb_task == '1'):
                child.set_style(regular_node_style_bb)
            else:
                child.set_style(regular_node_style_none)

            if (genome_id) == '1' or genome_id == '2': ## identify the roots
                if ( 'bcccccccccyy' in genome ):
                    child.set_style(separated_style)
                else:
                    child.set_style(intertwined_style)

            tree[genome_id]['node'] = child

           
        if ( genome_id == dominant_id ): ## I'm a dominant!
            if not tree[genome_id]['dominant']: ## first time, don't need to do this over and over again

                dominant_node_ids.append(genome_id) ## keep track of our dominants

                tree[genome_id]['dominant'] = True ## toggle it
               

                ## create the map task image
                dominant_map_task = lineage_file +"_dominant_map_task.png"    

                if not options.phylogeny_only:
                    print dominant_map_task
                    os.system("python "+ path_to_draw_map_task +" -t "+ dominant_map_task +" analyze/map_tasks-"+update+"/tasksites.org-"+genome_id+".dat*")

                tree[genome_id]['node'].add_face(ImgFace(dominant_map_task), 1, position='aligned')
                #print "HELLO"

                ## set the appropriate style
                if ( fluct_task == '1' and bb_task == '1'):
                    tree[genome_id]['node'].set_style(dominant_node_style_fluct_bb)
                elif (fluct_task == '1'):
                    tree[genome_id]['node'].set_style(dominant_node_style_fluct)
                elif (bb_task == '1'):
                    tree[genome_id]['node'].set_style(dominant_node_style_bb)
                else:
                    tree[genome_id]['node'].set_style(dominant_node_style_none)

            tree[genome_id]['dominant_update'] = update ## set the update for which I am a dominant
            tree[genome_id]['node'].add_feature("dominant",update)

            ## display the update of the dominant style
            ### if the update is during an antagonistic face...
            facebg = 'black'
            if (int(update) > 2000 and int(update) % 1000 > 500 ):
                facebg = 'red'
              #  print "HAI"
            tree[genome_id]['node'].add_face(TextFace(update, fgcolor=facebg), 0)


if not options.no_render:

    ## now, go through all the descendants of the dominants, and assign the proper branch lengths.
    for node_id in dominant_node_ids:
        dominant_node = tree[node_id]['node']
        parent = dominant_node.up ## take the first step

        found_branch_point_or_dominant = False
        while True:
            if len(parent.children) > 1:# or tree[parent.name]['dominant'] == True: ## there is more than one child, or I'm a dominant, which means I'm a branch
                #print "FORK"
                break
            elif tree[parent.name]['dominant'] == True:
                #print "PARENT DOMINANT"
                break
            else:
                parent = parent.up ## move up one

        total_distance = dominant_node.get_distance( parent )
        dominant_node.dist = total_distance ## set it.
        #dominant_node.add_face(TextFace(total_distance), 0) ## add in the face



    #tree_phylogeny.sort_descendants()
    tree_phylogeny.prune( dominant_node_ids )
    tree_phylogeny.ladderize()

    tree_phylogeny.render(outfile_name, tree_style=ts)
